calculating performance of an application 2 ways:

1. find time when strat and subtract the time when execution end (not so good)

2. Big O notation good


Way 1:

calculatestarttime()

def func():
    ....

calculateendtime()

check difference  =  performance of code

pros:
  easy to implement

cons:
  it based on computer or device  (low power device will be slow)
  Based on the processing on that time (running another program same time will effect)

  

Way 2: consiously writting code on O notation
Time Complexity or O(n) 
-----------------------

In DSA we have concept of calculating the performance of a code, for that we use O of n.

O = Stands for Counting operations or performance based on operations

n = Stands for input given, Based on input a program many run multiple times.

Why We need to Use DSA and O of n concept.

=> As a programmer we need to ensure whatever the code we written it should run on every computer whether it as new Apple silicon or old Intel Pentium chip it need to run.


a = a + 1               => 2 constant operations, adding a + 1, a = a + 1 it will end.
                        => 2 or O(1) 

for(i = 1; i < n; i++)  => 1 constant 5n based operations, i = 1 constant based on ninput 5 operations
    a = a + 1           => 5n + 1 or O(n)


for(i = 1; i < n; i++)     => Outside loop 1 N and Inside loop 1 N, based on Outside loop N input 
    a = a + 1                 inside Loop operations will change. 
    for(j = 1; j < n; j++) => 5n + 1 and 5n + 1 or O(n square)
        b = b + 1
               

How program performance calculated?

=>Best case
=>Average case
=>Worst case

As a programmer we need to avoid the worst case using DSA


O(3),O(5),O(8)          = O(1) any way it is constant all will execute one time only

O(3n),O(5n),O(8n)       = O(n) avoid count of operations,consider only n it only effect program.

O(300n),O(300n + 50000) = O(n) avoid count of operations and constant ,consider n it effect program. 
                            
O(2n square), O(10n square) = O(n square) avoid operations may depend only on n square

2n square + 2n + 3          = n square + n or O(n square) avoid n compare to N squr is small as math

DSA Cases (best,average,worst)
---------
Input of n and N case also is important

O(1)                    => constant
O(log n)                => logarithmic
O(n)                    => linear
O(n log n)              => linear logarithmic
O(n ^ 2)                => quadratic
O(n ^ 3)                => qube


Big O notation.jpg check it for more